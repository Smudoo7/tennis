
<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>TCO Doppelmaster 2025 ‚Äì Live-Dashboard + Admin</title>
<style>
  :root{
    --bg: #0f1220;
    --card: #15192e;
    --muted: #8b91a7;
    --text: #e7e9f3;
    --accent: #6ee7b7;
    --accent-2: #60a5fa;
    --danger: #f87171;
    --warn: #fbbf24;
    --shadow: 0 10px 30px rgba(0,0,0,.35);
    --radius: 16px;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, "Helvetica Neue", Arial, "Noto Sans";
    background: radial-gradient(1200px 800px at 20% -10%, #1b2146 0%, #12162a 50%, #0d1020 100%);
    color:var(--text);
    line-height:1.45;
  }
  header{
    position:sticky; top:0; z-index:10;
    backdrop-filter: blur(10px);
    background: rgba(15,18,32,.7);
    padding:12px 16px; border-bottom:1px solid #1f2446;
  }
  .container{max-width:1200px; margin:0 auto; padding:16px}
  h1{font-size:clamp(22px, 3vw, 32px); margin:6px 0 4px}
  .sub{color:var(--muted); font-size:14px}
  .grid{display:grid; gap:16px}
  .grid.cols-3{grid-template-columns: repeat(3, minmax(0,1fr));}
  .grid.cols-2{grid-template-columns: repeat(2, minmax(0,1fr));}
  .grid.cols-4{grid-template-columns: repeat(4, minmax(0,1fr));}
  @media (max-width: 1024px){
    .grid.cols-3,.grid.cols-2,.grid.cols-4{grid-template-columns: 1fr;}
  }
  .tabs{display:flex; gap:8px; flex-wrap:wrap; margin:16px 0}
  .tab{
    padding:10px 14px; border:1px solid #26305f; border-radius:999px; cursor:pointer;
    color:var(--muted); background:#0f142a; transition:.2s;
  }
  .tab.active{color:#0c1326; background:linear-gradient(135deg, var(--accent), var(--accent-2)); border-color:transparent; font-weight:600}
  .card{
    background: linear-gradient(180deg, rgba(255,255,255,.02), transparent) , var(--card);
    border:1px solid #222a52;
    border-radius: var(--radius);
    box-shadow: var(--shadow);
    padding:16px;
  }
  .card h2{margin:0 0 10px; font-size:18px}
  .muted{color:var(--muted)}
  .row{display:flex; gap:12px; align-items:center; flex-wrap:wrap}
  .badge{
    padding:4px 8px; font-size:12px; border-radius:999px; border:1px solid #2d3666; color:var(--muted);
    background:#0f142a;
  }
  table{width:100%; border-collapse:collapse; font-size:14px; overflow:hidden; border-radius:12px}
  thead th{
    text-align:left; font-weight:600; color:#aab2d8; background:#0f142a; border-bottom:1px solid #26305f;
    padding:10px 8px;
  }
  tbody td{padding:10px 8px; border-bottom:1px dashed #253060}
  tbody tr:hover{background:#10163a}
  .kpi{display:flex; gap:12px; flex-wrap:wrap}
  .kpi .tile{
    flex:1 1 160px;
    background: radial-gradient(400px 200px at 120% -20%, rgba(96,165,250,.2), transparent 70%) , #121734;
    border:1px solid #23306a; border-radius:16px; padding:14px;
  }
  .tile .label{font-size:12px; color:var(--muted)}
  .tile .value{font-size:22px; font-weight:700}
  input[type="number"], input[type="text"], select{
    background:#0e1431; border:1px solid #2b3568; color:var(--text); border-radius:10px; padding:6px 8px;
  }
  input[type="number"]{ width:70px; }
  .btn{
    appearance:none; border:none; border-radius:12px; padding:10px 14px; cursor:pointer;
    color:#0b1225; background:linear-gradient(135deg, var(--accent), var(--accent-2)); font-weight:700;
    box-shadow: 0 8px 20px rgba(96,165,250,.25);
  }
  .btn.ghost{background:#0f142a; color:var(--text); border:1px solid #273063; box-shadow:none}
  .pill{display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border-radius:999px; background:#0f142a; border:1px solid #2b3568; color:var(--muted); font-size:12px}
  .split{display:grid; grid-template-columns: 1fr 1fr; gap:16px}
  @media (max-width: 900px){ .split{grid-template-columns: 1fr;} }
  .bracket{display:grid; grid-template-columns: 1fr 1fr 1fr; gap:16px}
  .match-card{border:1px solid #2d376b; border-radius:14px; padding:10px; background:#0f142a}
  .match-card .title{color:#a8b2e2; font-size:12px; margin-bottom:8px}
  .team-row{display:flex; align-items:center; justify-content:space-between; gap:8px; margin:6px 0}
  .team-row .name{font-weight:600}
  .team-row input{width:64px}
  .winner{color:var(--accent)}
  .loser{color:var(--muted)}
  .footer{margin-top:24px; color:var(--muted); font-size:12px}
  .hint{font-size:12px; color:var(--muted)}
  .sync{display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border-radius:999px; border:1px solid #2b3568; background:#0f142a; color:var(--muted); font-size:12px}
  .sync.ok{color:#10b981}
  .sync.err{color:#f87171}
  .label{font-size:12px; color:var(--muted);}
  .admin-grid{display:grid; grid-template-columns: 1fr 1fr; gap:16px}
  @media (max-width: 900px){ .admin-grid{grid-template-columns: 1fr;} }
</style>
</head>
<body>
  <header>
    <div class="container">
      <div class="row" style="justify-content:space-between; align-items:center">
        <div>
          <h1>üèÜ TCO Doppelmaster 2025 ‚Äì Gruppenphase & KO</h1>
          <div class="sub">4 Pl√§tze ¬∑ Gruppe A (Platz 1‚Äì2) ¬∑ Gruppe B (Platz 3‚Äì4)</div>
        </div>
        <div class="row">
          <span id="syncBadge" class="sync">üîÑ Verbinden‚Ä¶</span>
          <button class="btn" id="downloadJson">Export</button>
          <button class="btn ghost" id="resetAll">Lokal zur√ºcksetzen</button>
        </div>
      </div>
      <div class="kpi" id="kpis"></div>
      <div class="tabs" id="tabs">
        <button class="tab active" data-tab="plan">Spielplan</button>
        <button class="tab" data-tab="tables">Live‚ÄëTabellen</button>
        <button class="tab" data-tab="ko">KO‚ÄëPhase</button>
        <button class="tab" data-tab="admin">Admin</button>
      </div>
    </div>
  </header>

  <main class="container">
    <section id="plan" class="card">
      <div class="row" style="justify-content:space-between">
        <h2>üóìÔ∏è Spielplan (Gruppenphase)</h2>
        <span class="pill">Server‚ÄëSync + lokaler Cache</span>
      </div>
      <div class="hint">Ranking: Siege ‚Üí Satzdiff ‚Üí Spieldiff ‚Üí Direktvergleich.</div>
      <div id="schedule"></div>
    </section>

    <section id="tables" class="card" style="display:none">
      <h2>üìä Live‚ÄëTabellen</h2>
      <div class="split">
        <div>
          <div class="row"><h3>Gruppe A</h3><span class="badge">Platz 1‚Äì2</span></div>
          <div id="tableA"></div>
        </div>
        <div>
          <div class="row"><h3>Gruppe B</h3><span class="badge">Platz 3‚Äì4</span></div>
          <div id="tableB"></div>
        </div>
      </div>
    </section>

    <section id="ko" class="card" style="display:none">
      <h2>ü•á KO‚ÄëPhase</h2>
      <div class="hint">Wird automatisch bef√ºllt, sobald beide Gruppen fertig sind.</div>
      <div id="koBracket" class="bracket"></div>
    </section>

    <section id="admin" class="card" style="display:none">
      <div class="row" style="justify-content:space-between">
        <h2>üõ†Ô∏è Admin ‚Äì Teams & Einstellungen</h2>
        <span class="pill">√Ñnderungen speichern ‚Üí Spielplan wird neu generiert</span>
      </div>
      <div class="admin-grid">
        <div class="card">
          <h3>Gruppe A</h3>
          <div class="row"><span class="label">Anzahl Teams</span><input type="number" id="countA" min="2" max="12"></div>
          <div id="namesA"></div>
          <div class="row" style="margin-top:8px">
            <input type="checkbox" id="avoidFirstA5">
            <label for="avoidFirstA5" class="label">Vermeide, dass letztes Team in Gruppe A im ersten Spiel steht</label>
          </div>
        </div>
        <div class="card">
          <h3>Gruppe B</h3>
          <div class="row"><span class="label">Anzahl Teams</span><input type="number" id="countB" min="2" max="12"></div>
          <div id="namesB"></div>
        </div>
      </div>
      <div class="row" style="justify-content:flex-end; margin-top:12px">
        <button class="btn ghost" id="adminCancel">Verwerfen</button>
        <button class="btn" id="adminSave">Speichern & neu planen</button>
      </div>
    </section>

    <div class="footer">Zentrale Speicherung via Netlify Functions (Blobs). Lokaler Cache als Fallback.</div>
  </main>

<script>
// ===== Config =====
const TOURNAMENT_NAME = "TCO Doppelmaster 2025";
const TOURNAMENT_ID = "TCO%20Doppelmaster%202025"; // URL-encodet
const API = `/.netlify/functions/state?t=${TOURNAMENT_ID}`;
// Optionales Admin-Token (wenn gesetzt)
const ADMIN_TOKEN = ""; // z.B. "mein-secret"
const USE_LOCAL_CACHE = true;

// ===== Helpers: Server Sync =====
const KEY_LOCAL = "tco_doppelmaster_state_v3";
const syncBadge = document.getElementById("syncBadge");
function setSyncStatus(text, cls=""){ syncBadge.textContent = text; syncBadge.className = "sync " + cls; }

async function serverLoad() {
  try {
    const res = await fetch(API, { method: "GET" });
    if(!res.ok) throw new Error("GET failed");
    const data = await res.json();
    setSyncStatus("‚úÖ Verbunden", "ok");
    return data || {};
  } catch(e) {
    setSyncStatus("‚ö†Ô∏è Offline/Serverfehler", "err");
    return null;
  }
}
async function serverPut(fullState){
  const headers = { "content-type": "application/json" };
  if(ADMIN_TOKEN) headers["x-admin-token"] = ADMIN_TOKEN;
  const res = await fetch(API, { method: "PUT", headers, body: JSON.stringify(fullState) });
  if(!res.ok) throw new Error("PUT failed");
}
async function serverPatch(pathArray, value){
  const headers = { "content-type": "application/json" };
  if(ADMIN_TOKEN) headers["x-admin-token"] = ADMIN_TOKEN;
  const res = await fetch(API, { method: "PATCH", headers, body: JSON.stringify({ path: pathArray, value }) });
  if(!res.ok) throw new Error("PATCH failed");
}

// ===== Local cache =====
function loadLocal(){ try { return JSON.parse(localStorage.getItem(KEY_LOCAL)) || {}; } catch { return {}; } }
function saveLocal(s){ try { localStorage.setItem(KEY_LOCAL, JSON.stringify(s)); } catch {} }
function resetLocal(){ localStorage.removeItem(KEY_LOCAL); }

// ===== App State =====
// structure: {config:{groups:{A:[...],B:[...]}, avoidFirstA5:bool}, schedule:[...], matches:{g1:{...}}, KO:{...} }
let state = {};

function defaultConfig(){
  return {
    groups: { A: ["A1","A2","A3","A4","A5"], B: ["B1","B2","B3","B4"] },
    avoidFirstA5: true
  };
}

function ensureState(){
  if(!state.config) state.config = defaultConfig();
  if(!state.schedule) state.schedule = generateSchedule(state.config);
  if(!state.matches) state.matches = {};
  for(const [id] of state.schedule){
    if(!state.matches["g"+id]) state.matches["g"+id] = {sets1:"", sets2:"", games1:"", games2:""};
  }
  if(!state.KO) state.KO = {
    SF1:{t1:"A1", t2:"B2", s1:"", s2:""},
    SF2:{t1:"B1", t2:"A2", s1:"", s2:""},
    F:{t1:"", t2:"", s1:"", s2:""},
    P3:{t1:"", t2:"", s1:"", s2:""}
  };
}

// ===== Round-Robin Generator (circle method) =====
function roundRobin(teams){
  const list = teams.slice();
  if(list.length % 2 === 1) list.push("BYE");
  const n = list.length;
  const rounds = n-1;
  const half = n/2;
  const out = [];
  const arr = list.slice();
  for(let r=0; r<rounds; r++){
    const pairings = [];
    for(let i=0; i<half; i++){
      const t1 = arr[i], t2 = arr[n-1-i];
      if(t1!=="BYE" && t2!=="BYE") pairings.push([t1,t2]);
    }
    out.push(pairings);
    // rotate (keep arr[0] fixed)
    const fixed = arr[0];
    const rest = arr.slice(1);
    rest.unshift(rest.pop());
    arr.splice(0, arr.length, fixed, ...rest);
  }
  return out; // array of rounds, each list of [t1,t2]
}

function generateSchedule(config){
  const A = config.groups.A.slice();
  const B = config.groups.B.slice();
  // build RR per group
  const rrA = roundRobin(A);
  const rrB = roundRobin(B);
  // optional constraint: avoid that last team of A is in first match of Runde 1 Platz 1
  // We'll swap first pairing if needed.
  if(config.avoidFirstA5 && rrA.length>0 && rrA[0].length>0){
    const lastA = A[A.length-1];
    const firstPair = rrA[0][0];
    if(firstPair.includes(lastA)){
      // find another pair in round 1 to swap with
      for(let i=1;i<rrA[0].length;i++){
        if(!rrA[0][i].includes(lastA)){
          const tmp = rrA[0][0];
          rrA[0][0] = rrA[0][i];
          rrA[0][i] = tmp;
          break;
        }
      }
    }
  }

  // Now interleave to global schedule with 4 courts per "Runde"
  const totalRounds = Math.max(rrA.length, rrB.length);
  const schedule = []; // [id, 'Runde X', 'Platz Y', t1,t2, 'A'|'B']
  let id = 1;
  for(let r=0; r<totalRounds; r++){
    const aPairs = rrA[r] || [];
    const bPairs = rrB[r] || [];
    // place up to 2 A pairs on Platz 1 & 2
    for(let i=0;i<2;i++){
      if(aPairs[i]){
        schedule.push([id++, `Runde ${r+1}`, `Platz ${i+1}`, aPairs[i][0], aPairs[i][1], 'A']);
      }
    }
    // place up to 2 B pairs on Platz 3 & 4
    for(let i=0;i<2;i++){
      if(bPairs[i]){
        schedule.push([id++, `Runde ${r+1}`, `Platz ${i+3}`, bPairs[i][0], bPairs[i][1], 'B']);
      }
    }
  }
  return schedule;
}

// ===== UI Rendering =====
function renderSchedule(){
  const wrap = document.getElementById("schedule");
  wrap.innerHTML = "";
  const sched = state.schedule;
  let currentRound = "";
  let groupWrap = null;
  sched.forEach(([id, round, court, t1, t2, grp], idx) => {
    if(round !== currentRound){
      currentRound = round;
      const r = document.createElement("div");
      r.className = "card";
      r.style.margin = "12px 0";
      const startId = id;
      r.innerHTML = `<div class="row" style="justify-content:space-between; align-items:center">
        <div class="row"><h3 style="margin:0">${round}</h3><span class="badge">Parallel: bis zu 4 Pl√§tze</span></div>
        <span class="muted">ab Spiel #${startId}</span>
      </div>`;
      groupWrap = document.createElement("div");
      groupWrap.className = "grid cols-2";
      r.appendChild(groupWrap);
      wrap.appendChild(r);
    }
    const m = state.matches["g"+id] || {sets1:"", sets2:"", games1:"", games2:""};
    const card = document.createElement("div");
    card.className = "match-card";
    card.innerHTML = `
      <div class="title">#${id} ¬∑ ${court} ¬∑ Gruppe ${grp}</div>
      <div class="team-row">
        <span class="name">${t1}</span>
        <div class="row">
          <label class="muted">S√§tze</label>
          <input type="number" min="0" step="1" id="s1_${id}" value="${m.sets1}">
          <label class="muted">Spiele</label>
          <input type="number" min="0" step="1" id="g1_${id}" value="${m.games1}">
        </div>
      </div>
      <div class="team-row">
        <span class="name">${t2}</span>
        <div class="row">
          <label class="muted">S√§tze</label>
          <input type="number" min="0" step="1" id="s2_${id}" value="${m.sets2}">
          <label class="muted">Spiele</label>
          <input type="number" min="0" step="1" id="g2_${id}" value="${m.games2}">
        </div>
      </div>
      <div class="row" style="justify-content:flex-end">
        <button class="btn ghost" id="clear_${id}">L√∂schen</button>
      </div>
    `;
    groupWrap.appendChild(card);

    function bind(idStr, key){
      const el = document.getElementById(idStr);
      if(!el) return;
      el.addEventListener("input", async (e)=>{
        state.matches["g"+id] = state.matches["g"+id] || {sets1:"", sets2:"", games1:"", games2:""};
        state.matches["g"+id][key] = e.target.value;
        if(USE_LOCAL_CACHE) saveLocal(state);
        try {
          await serverPatch(["matches","g"+id], state.matches["g"+id]);
          setSyncStatus("‚úÖ Synchronisiert", "ok");
        } catch {
          setSyncStatus("‚ö†Ô∏è Nicht synchronisiert (lokal zwischengespeichert)", "err");
        }
        updateTables();
        renderKO();
        updateKPIs();
      });
    }
    bind(`s1_${id}`, "sets1");
    bind(`s2_${id}`, "sets2");
    bind(`g1_${id}`, "games1");
    bind(`g2_${id}`, "games2");
    document.getElementById(`clear_${id}`).addEventListener("click", async ()=>{
      state.matches["g"+id] = {sets1:"", sets2:"", games1:"", games2:""};
      if(USE_LOCAL_CACHE) saveLocal(state);
      try{ await serverPatch(["matches","g"+id], state.matches["g"+id]); setSyncStatus("‚úÖ Synchronisiert","ok"); }
      catch{ setSyncStatus("‚ö†Ô∏è Nicht synchronisiert (lokal zwischengespeichert)","err"); }
      renderSchedule(); updateTables(); renderKO(); updateKPIs();
    });
  });
}

function isNumber(x){ return x!=="" && !isNaN(Number(x)); }

function computeStandings(){
  const groups = state.config.groups;
  const standings = { A:{}, B:{} };
  for(const g of ["A","B"]){
    for(const t of groups[g]) standings[g][t] = {Team:t, GP:0, W:0, L:0, SetsPlus:0, SetsMinus:0, GamesPlus:0, GamesMinus:0, Pts:0};
  }
  const h2h = {A:{}, B:{}}; for(const g of ["A","B"]){ for(const t of groups[g]) h2h[g][t] = {}; }

  state.schedule.forEach(([id, round, court, t1, t2, grp])=>{
    const r = state.matches["g"+id] || {};
    const s1 = Number(r.sets1), s2 = Number(r.sets2);
    const g1 = Number(r.games1), g2 = Number(r.games2);
    const haveSets = isNumber(r.sets1) && isNumber(r.sets2);
    const haveGames = isNumber(r.games1) && isNumber(r.games2);
    if(!haveSets) return;
    standings[grp][t1].GP++; standings[grp][t2].GP++;
    standings[grp][t1].SetsPlus += s1; standings[grp][t1].SetsMinus += s2;
    standings[grp][t2].SetsPlus += s2; standings[grp][t2].SetsMinus += s1;
    if(haveGames){
      standings[grp][t1].GamesPlus += g1; standings[grp][t1].GamesMinus += g2;
      standings[grp][t2].GamesPlus += g2; standings[grp][t2].GamesMinus += g1;
    }
    if(s1>s2){ standings[grp][t1].W++; standings[grp][t2].L++; standings[grp][t1].Pts++; }
    else if(s2>s1){ standings[grp][t2].W++; standings[grp][t1].L++; standings[grp][t2].Pts++; }
    const winner = s1===s2 ? null : (s1>s2 ? t1 : t2);
    const loser  = s1===s2 ? null : (s1>s2 ? t2 : t1);
    if(winner && loser){ h2h[grp][winner][loser] = (h2h[grp][winner][loser] || 0) + 1; }
  });

  function sortGroup(grp){
    const arr = Object.values(standings[grp]);
    arr.sort((a,b)=>{
      const p = b.Pts - a.Pts; if(p) return p;
      const sd = (b.SetsPlus-b.SetsMinus) - (a.SetsPlus-a.SetsMinus); if(sd) return sd;
      const gd = (b.GamesPlus-b.GamesMinus) - (a.GamesPlus-a.GamesMinus); if(gd) return gd;
      const h = ((a.Team in h2h[grp] && b.Team in h2h[grp][a.Team]) ? h2h[grp][a.Team][b.Team] : 0)
              - ((b.Team in h2h[grp] && a.Team in h2h[grp][b.Team]) ? h2h[grp][b.Team][a.Team] : 0);
      if(h) return -h;
      return a.Team.localeCompare(b.Team);
    });
    arr.forEach((r,i)=> r.Rang = i+1);
    return arr;
  }
  return {A: sortGroup("A"), B: sortGroup("B")};
}

function tableHTML(rows){
  return `
  <table>
    <thead>
      <tr>
        <th>#</th><th>Team</th><th>Spiele</th><th>Siege</th><th>Niederl.</th>
        <th>S√§tze +/‚àí</th><th>Spiele +/‚àí</th><th>Punkte</th>
      </tr>
    </thead>
    <tbody>
      ${rows.map(r=>`
        <tr>
          <td>${r.Rang}</td>
          <td>${r.Team}</td>
          <td>${r.GP}</td>
          <td>${r.W}</td>
          <td>${r.L}</td>
          <td>${r.SetsPlus}:${r.SetsMinus} (${r.SetsPlus - r.SetsMinus})</td>
          <td>${r.GamesPlus}:${r.GamesMinus} (${r.GamesPlus - r.GamesMinus})</td>
          <td>${r.Pts}</td>
        </tr>
      `).join("")}
    </tbody>
  </table>`;
}

function updateTables(){
  const {A, B} = computeStandings();
  document.getElementById("tableA").innerHTML = tableHTML(A);
  document.getElementById("tableB").innerHTML = tableHTML(B);
}

function allGroupFinished(grp){
  const total = state.schedule.filter(s=>s[5]===grp).length;
  let have = 0;
  state.schedule.forEach(([id, , , , , g])=>{
    const r = state.matches["g"+id] || {};
    if(g===grp && isNumber(r.sets1) && isNumber(r.sets2)) have++;
  });
  return have === total && total>0;
}

function renderKO(){
  const br = document.getElementById("koBracket");
  br.innerHTML = "";
  const finishedA = allGroupFinished("A");
  const finishedB = allGroupFinished("B");
  const ready = finishedA && finishedB;
  const {A, B} = computeStandings();
  const A1 = A[0]?.Team, A2 = A[1]?.Team;
  const B1 = B[0]?.Team, B2 = B[1]?.Team;
  const K = state.KO;
  if(ready){
    K.SF1.t1 = A1; K.SF1.t2 = B2;
    K.SF2.t1 = B1; K.SF2.t2 = A2;
    const winner = (m)=> (m.s1===""||m.s2==="") ? null : (Number(m.s1)>Number(m.s2)? m.t1 : m.t2);
    const loser  = (m)=> (m.s1===""||m.s2==="") ? null : (Number(m.s1)>Number(m.s2)? m.t2 : m.t1);
    const w1 = winner(K.SF1), w2 = winner(K.SF2);
    const l1 = loser(K.SF1), l2 = loser(K.SF2);
    if(w1 && w2){ K.F.t1 = w1; K.F.t2 = w2; }
    if(l1 && l2){ K.P3.t1 = l1; K.P3.t2 = l2; }
  }
  function matchCard(key, title){
    const m = K[key];
    const el = document.createElement("div");
    el.className = "match-card";
    el.innerHTML = `
      <div class="title">${title}</div>
      <div class="team-row">
        <span class="name">${m.t1 || "‚Äî"}</span>
        <div class="row"><label class="muted">S√§tze</label>
          <input type="number" min="0" step="1" id="${key}_s1" value="${m.s1}">
        </div>
      </div>
      <div class="team-row">
        <span class="name">${m.t2 || "‚Äî"}</span>
        <div class="row"><label class="muted">S√§tze</label>
          <input type="number" min="0" step="1" id="${key}_s2" value="${m.s2}">
        </div>
      </div>
      <div class="hint">${ready? "Automatisch aus Gruppentabellen bef√ºllt." : "Wartet auf Abschluss der Gruppenphase."}</div>
    `;
    setTimeout(()=>{
      const s1 = document.getElementById(`${key}_s1`);
      const s2 = document.getElementById(`${key}_s2`);
      if(s1) s1.addEventListener("input", async (e)=>{
        state.KO[key].s1 = e.target.value;
        if(USE_LOCAL_CACHE) saveLocal(state);
        try{ await serverPatch(["KO", key], state.KO[key]); setSyncStatus("‚úÖ Synchronisiert","ok"); }
        catch{ setSyncStatus("‚ö†Ô∏è Nicht synchronisiert (lokal zwischengespeichert)","err"); }
        renderKO();
      });
      if(s2) s2.addEventListener("input", async (e)=>{
        state.KO[key].s2 = e.target.value;
        if(USE_LOCAL_CACHE) saveLocal(state);
        try{ await serverPatch(["KO", key], state.KO[key]); setSyncStatus("‚úÖ Synchronisiert","ok"); }
        catch{ setSyncStatus("‚ö†Ô∏è Nicht synchronisiert (lokal zwischengespeichert)","err"); }
        renderKO();
      });
    }, 0);
    return el;
  }
  const col1 = document.createElement("div");
  const col2 = document.createElement("div");
  const col3 = document.createElement("div");
  col1.appendChild(matchCard("SF1","Halbfinale 1 (A1 vs B2)"));
  col1.appendChild(matchCard("P3","Spiel um Platz 3"));
  col3.appendChild(matchCard("SF2","Halbfinale 2 (B1 vs A2)"));
  col2.appendChild(matchCard("F","Finale"));
  br.appendChild(col1); br.appendChild(col2); br.appendChild(col3);
}

function updateKPIs(){
  const played = Object.keys(state.matches||{}).filter(k=>{
    const r = state.matches[k]; return isNumber(r?.sets1)&&isNumber(r?.sets2);
  }).length;
  const total = state.schedule.length;
  const doneA = allGroupFinished("A");
  const doneB = allGroupFinished("B");
  const kpis = document.getElementById("kpis");
  kpis.innerHTML = `
    <div class="tile"><div class="label">Turnier</div><div class="value">${TOURNAMENT_NAME}</div></div>
    <div class="tile"><div class="label">Teams A/B</div><div class="value">${state.config.groups.A.length} / ${state.config.groups.B.length}</div></div>
    <div class="tile"><div class="label">Gespielte Spiele</div><div class="value">${played}/${total}</div></div>
    <div class="tile"><div class="label">Gruppe A ‚Äì Status</div><div class="value">${doneA? "abgeschlossen" : "l√§uft"}</div></div>
    <div class="tile"><div class="label">Gruppe B ‚Äì Status</div><div class="value">${doneB? "abgeschlossen" : "l√§uft"}</div></div>
  `;
}

// ===== Admin UI =====
function renderAdmin(){
  const cfg = state.config;
  const countA = document.getElementById("countA");
  const countB = document.getElementById("countB");
  const namesA = document.getElementById("namesA");
  const namesB = document.getElementById("namesB");
  const avoid = document.getElementById("avoidFirstA5");
  countA.value = cfg.groups.A.length;
  countB.value = cfg.groups.B.length;
  avoid.checked = !!cfg.avoidFirstA5;

  function renderNames(container, arr, prefix){
    container.innerHTML = "";
    arr.forEach((name, idx)=>{
      const row = document.createElement("div");
      row.className = "row";
      row.innerHTML = `<span class="label" style="width:80px">${prefix}${idx+1}</span>
        <input type="text" value="${name}" id="${prefix}${idx+1}_name" style="flex:1; min-width:200px">`;
      container.appendChild(row);
    });
  }
  renderNames(namesA, cfg.groups.A, "A");
  renderNames(namesB, cfg.groups.B, "B");

  function adjustCount(which, newCount){
    const list = cfg.groups[which];
    const current = list.length;
    if(newCount>current){
      for(let i=current; i<newCount; i++){ list.push(`${which}${i+1}`); }
    }else if(newCount<current){
      list.splice(newCount);
    }
  }

  countA.oninput = ()=>{
    const n = Math.max(2, Math.min(12, Number(countA.value)||2));
    adjustCount("A", n);
    renderAdmin();
  };
  countB.oninput = ()=>{
    const n = Math.max(2, Math.min(12, Number(countB.value)||2));
    adjustCount("B", n);
    renderAdmin();
  };

  document.getElementById("adminCancel").onclick = ()=>{
    renderAdmin();
  };

  document.getElementById("adminSave").onclick = async ()=>{
    // read names back
    const newA = [];
    const newB = [];
    for(let i=0;i<cfg.groups.A.length;i++){
      const v = document.getElementById(`A${i+1}_name`).value.trim() || `A${i+1}`;
      newA.push(v);
    }
    for(let i=0;i<cfg.groups.B.length;i++){
      const v = document.getElementById(`B${i+1}_name`).value.trim() || `B${i+1}`;
      newB.push(v);
    }
    cfg.groups.A = newA;
    cfg.groups.B = newB;
    cfg.avoidFirstA5 = document.getElementById("avoidFirstA5").checked;

    // regenerate schedule
    const newSchedule = generateSchedule(cfg);
    // reset matches mapping to match new schedule id space
    const newMatches = {};
    for(const [id] of newSchedule){
      newMatches["g"+id] = state.matches["g"+id] || {sets1:"", sets2:"", games1:"", games2:""};
    }
    state.schedule = newSchedule;
    state.matches = newMatches;
    // reset KO
    state.KO = { SF1:{t1:"",t2:"",s1:"",s2:""}, SF2:{t1:"",t2:"",s1:"",s2:""}, F:{t1:"",t2:"",s1:"",s2:""}, P3:{t1:"",t2:"",s1:"",s2:""} };

    if(USE_LOCAL_CACHE) saveLocal(state);
    try{
      await serverPatch(["config"], cfg);
      await serverPatch(["schedule"], newSchedule);
      await serverPatch(["matches"], newMatches);
      await serverPatch(["KO"], state.KO);
      setSyncStatus("‚úÖ Synchronisiert", "ok");
    }catch{
      setSyncStatus("‚ö†Ô∏è Nicht synchronisiert (lokal zwischengespeichert)","err");
    }
    renderSchedule(); updateTables(); renderKO(); updateKPIs(); renderAdmin();
  };
}

// ===== Tabs =====
document.querySelectorAll(".tab").forEach(t=>{
  t.addEventListener("click", ()=>{
    document.querySelectorAll(".tab").forEach(x=>x.classList.remove("active"));
    t.classList.add("active");
    document.querySelectorAll("main section").forEach(s=> s.style.display="none");
    document.getElementById(t.dataset.tab).style.display = "";
  });
});

// Export & Reset (nur lokal)
document.getElementById("downloadJson").addEventListener("click", ()=>{
  const blob = new Blob([JSON.stringify(state, null, 2)], {type:"application/json"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url; a.download = "tco_doppelmaster_state.json"; a.click();
  setTimeout(()=>URL.revokeObjectURL(url), 2000);
});
document.getElementById("resetAll").addEventListener("click", ()=>{
  if(confirm("Nur den lokalen Cache l√∂schen? (Serverdaten bleiben erhalten)")){
    resetLocal(); location.reload();
  }
});

// Boot
(async function boot(){
  const fromServer = await serverLoad();
  if(fromServer){ state = fromServer; }
  else if(USE_LOCAL_CACHE){ state = loadLocal(); }
  else { state = {}; }
  ensureState();
  if(USE_LOCAL_CACHE) saveLocal(state);
  renderSchedule();
  updateTables();
  renderKO();
  updateKPIs();
  renderAdmin();
})();
</script>
</body>
</html>
