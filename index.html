
<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>TCO Doppelmaster 2025 ‚Äì Responsive Dashboard (Public‚ÄëMode + QR)</title>
<style>
  :root{
    --bg: #0f1220;
    --card: #15192e;
    --muted: #8b91a7;
    --text: #e7e9f3;
    --accent: #6ee7b7;
    --accent-2: #60a5fa;
    --danger: #f87171;
    --warn: #fbbf24;
    --shadow: 0 10px 30px rgba(0,0,0,.35);
    --radius: 16px;
    --safe-b: env(safe-area-inset-bottom, 0);
    --safe-t: env(safe-area-inset-top, 0);
  }
  *{box-sizing:border-box; -webkit-tap-highlight-color: transparent;}
  html,body{height:100%}
  body{
    margin:0;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, "Helvetica Neue", Arial, "Noto Sans";
    background: radial-gradient(1200px 800px at 20% -10%, #1b2146 0%, #12162a 50%, #0d1020 100%);
    color:var(--text);
    line-height:1.45;
  }
  @media (prefers-reduced-motion: reduce){
    *{scroll-behavior: auto; animation: none !important; transition: none !important;}
  }
  header{
    position:sticky; top:0; z-index:10;
    backdrop-filter: blur(10px);
    background: rgba(15,18,32,.7);
    padding:12px 16px calc(8px + var(--safe-t)); border-bottom:1px solid #1f2446;
  }
  .container{max-width:1200px; margin:0 auto; padding:16px}
  h1{font-size:clamp(18px, 3.2vw, 32px); margin:6px 0 4px}
  .sub{color:var(--muted); font-size:12px}
  .grid{display:grid; gap:12px}
  .grid.cols-2{grid-template-columns: repeat(2, minmax(0,1fr));}
  .grid.cols-3{grid-template-columns: repeat(3, minmax(0,1fr));}
  .grid.cols-4{grid-template-columns: repeat(4, minmax(0,1fr));}
  @media (max-width: 1024px){ .grid.cols-3,.grid.cols-4{grid-template-columns: repeat(2, 1fr);} }
  @media (max-width: 720px){ .grid.cols-2,.grid.cols-3,.grid.cols-4{grid-template-columns: 1fr;} }

  .tabs{display:flex; gap:8px; flex-wrap:wrap; margin:16px 0}
  .tab{ padding:10px 14px; border:1px solid #26305f; border-radius:999px; cursor:pointer;
    color:var(--muted); background:#0f142a; transition:.2s; }
  .tab.active{color:#0c1326; background:linear-gradient(135deg, var(--accent), var(--accent-2)); border-color:transparent; font-weight:600}

  .card{
    background: linear-gradient(180deg, rgba(255,255,255,.02), transparent) , var(--card);
    border:1px solid #222a52;
    border-radius: var(--radius);
    box-shadow: var(--shadow);
    padding:14px;
  }
  .card h2{margin:0 0 10px; font-size:18px}
  .muted{color:var(--muted)}
  .row{display:flex; gap:12px; align-items:center; flex-wrap:wrap}
  .badge{ padding:4px 8px; font-size:12px; border-radius:999px; border:1px solid #2d3666; color:#9fb0e0; background:#0f142a;}
  .pill{display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border-radius:999px; background:#0f142a; border:1px solid #2b3568; color:#c7ceef; font-size:12px}

  table{width:100%; border-collapse:collapse; font-size:14px; overflow:hidden; border-radius:12px}
  thead th{ text-align:left; font-weight:600; color:#aab2d8; background:#0f142a; border-bottom:1px solid #26305f; padding:10px 8px;}
  tbody td{padding:10px 8px; border-bottom:1px dashed #253060}
  tbody tr:hover{background:#10163a}

  .kpi{display:grid; grid-template-columns: repeat(4, minmax(0,1fr)); gap:12px}
  .kpi .tile{ background: radial-gradient(400px 200px at 120% -20%, rgba(96,165,250,.2), transparent 70%) , #121734;
    border:1px solid #23306a; border-radius:16px; padding:14px; }
  .tile .label{font-size:12px; color:var(--muted)}
  .tile .value{font-size:18px; font-weight:700}
  @media (max-width: 900px){ .kpi{grid-template-columns: repeat(2, 1fr);} }
  @media (max-width: 520px){ .kpi{grid-template-columns: 1fr;} }

  input[type="number"], input[type="text"], input[type="password"], select{
    background:#0e1431; border:1px solid #2b3568; color:var(--text); border-radius:12px; padding:10px 12px; font-size:16px;
  }
  input[type="number"]{ width:88px; }
  input[type="password"]{ width:200px; }
  .btn{ appearance:none; border:none; border-radius:14px; padding:10px 14px; cursor:pointer;
    color:#0b1225; background:linear-gradient(135deg, var(--accent), var(--accent-2)); font-weight:800;
    box-shadow: 0 8px 20px rgba(96,165,250,.25); font-size:16px; }
  .btn.ghost{background:#0f142a; color:var(--text); border:1px solid #273063; box-shadow:none}

  .match-card{border:1px solid #2d376b; border-radius:16px; padding:12px; background:#0f142a}
  .match-card .title{color:#a8b2e2; font-size:12px; margin-bottom:8px}
  .team-row{display:flex; align-items:center; justify-content:space-between; gap:8px; margin:6px 0}
  .team-row .name{font-weight:700}
  .team-row input{width:100px}

  .hint{font-size:12px; color:var(--muted)}
  .sync{display:inline-flex; align-items:center; gap:8px; padding:8px 12px; border-radius:999px; border:1px solid #2b3568; background:#0f142a; color:var(--muted); font-size:12px}
  .sync.ok{color:#10b981}
  .sync.err{color:#f87171}
  .label{font-size:12px; color:var(--muted);}

  .accordion{border:1px solid #26305f; border-radius:12px; overflow:hidden; margin:10px 0; background:#0f142a}
  .acc-head{display:flex; justify-content:space-between; align-items:center; padding:12px 14px; cursor:pointer}
  .acc-body{display:none; padding:10px 12px}
  .acc-open .acc-body{display:block}
  .acc-open .acc-head .chev{transform: rotate(180deg)}
  .chev{transition: .2s transform;}

  .bottom-nav{
    position: fixed; left:0; right:0; bottom:0;
    background: rgba(12,15,30,.9);
    border-top:1px solid #20264a;
    display:grid; grid-template-columns: repeat(4, 1fr);
    padding:8px 8px calc(8px + var(--safe-b));
    z-index:20; backdrop-filter: blur(8px);
  }
  .bottom-nav button{
    background:none; border:none; color:#aeb5d9; font-size:12px; padding:8px 6px; border-radius:12px;
  }
  .bottom-nav button.active{ color:#0b1225; background:linear-gradient(135deg, var(--accent), var(--accent-2)); font-weight:800; }
  @media (min-width: 980px){ .bottom-nav{ display:none } }
  @media (max-width: 979px){ .tabs{ display:none } }

  main{ padding-bottom: calc(64px + var(--safe-b)); }

  /* QR Overlay */
  .overlay{
    position: fixed; inset:0; background: rgba(5,7,15,.8); backdrop-filter: blur(6px);
    display:none; align-items:center; justify-content:center; z-index:50;
  }
  .overlay.open{ display:flex }
  .qr-card{
    width:min(520px, 92vw);
    background: linear-gradient(180deg, rgba(255,255,255,.03), transparent), #121734;
    border:1px solid #263266; border-radius:18px; padding:16px; box-shadow: var(--shadow);
  }
  .qr-grid{ display:grid; grid-template-columns: 1fr; gap:12px; justify-items:center }
  .qr-grid img{ width: min(360px, 70vw); aspect-ratio:1; border-radius:12px; background:#fff }
  .qr-row{ display:flex; gap:8px; width:100% }
  .qr-row input{ flex:1 }
</style>
</head>
<body>
  <header>
    <div class="container">
      <div class="row" style="justify-content:space-between; align-items:center">
        <div>
          <h1>üèÜ TCO Doppelmaster 2025 <span id="modeBadge" class="badge"></span></h1>
          <div class="sub">Gruppenphase & KO ¬∑ 4 Pl√§tze ¬∑ A auf 1‚Äì2 ¬∑ B auf 3‚Äì4</div>
        </div>
        <div class="row" style="gap:8px">
          <span id="syncBadge" class="sync">üîÑ Verbinden‚Ä¶</span>
          <input type="password" id="adminTokenInput" placeholder="Admin‚ÄëToken" aria-label="Admin Token" />
          <button class="btn ghost" id="saveTokenBtn" title="Lokal speichern">Token</button>
          <button class="btn ghost" id="qrBtn" title="QR teilen">QR teilen</button>
          <button class="btn" id="downloadJson" title="Export JSON">Export</button>
        </div>
      </div>
      <div class="kpi" id="kpis"></div>
      <div class="tabs" id="tabs">
        <button class="tab active" data-tab="plan">Spielplan</button>
        <button class="tab" data-tab="tables">Tabellen</button>
        <button class="tab" data-tab="ko">KO</button>
        <button class="tab" data-tab="admin">Admin</button>
      </div>
    </div>
  </header>

  <main class="container">
    <section id="plan" class="card">
      <div class="row" style="justify-content:space-between">
        <h2>üóìÔ∏è Spielplan</h2>
        <span class="pill">Server‚ÄëSync nur mit Admin‚ÄëToken ‚Ä¢ lokaler Cache aktiv</span>
      </div>
      <div class="hint">Ranking: Siege ‚Üí Satzdiff ‚Üí Spieldiff ‚Üí Direktvergleich.</div>
      <div id="schedule"></div>
    </section>

    <section id="tables" class="card" style="display:none">
      <h2>üìä Live‚ÄëTabellen</h2>
      <div class="grid cols-2">
        <div>
          <div class="row"><h3>Gruppe A</h3><span class="badge">Platz 1‚Äì2</span></div>
          <div id="tableA"></div>
        </div>
        <div>
          <div class="row"><h3>Gruppe B</h3><span class="badge">Platz 3‚Äì4</span></div>
          <div id="tableB"></div>
        </div>
      </div>
    </section>

    <section id="ko" class="card" style="display:none">
      <h2>ü•á KO‚ÄëPhase</h2>
      <div class="hint">Wird automatisch bef√ºllt, sobald beide Gruppen fertig sind.</div>
      <div id="koBracket" class="grid cols-2"></div>
    </section>

    <section id="admin" class="card" style="display:none">
      <div class="row" style="justify-content:space-between">
        <h2>üõ†Ô∏è Admin</h2>
        <span class="pill">Speichern ‚Üí Spielplan neu generiert</span>
      </div>
      <div class="grid cols-2">
        <div class="card">
          <h3>Gruppe A</h3>
          <div class="row"><span class="label">Anzahl Teams</span><input type="number" id="countA" min="2" max="12"></div>
          <div id="namesA"></div>
          <div class="row" style="margin-top:8px">
            <input type="checkbox" id="avoidFirstA5">
            <label for="avoidFirstA5" class="label">Vermeide, dass letztes Team in Gruppe A im ersten Spiel steht</label>
          </div>
        </div>
        <div class="card">
          <h3>Gruppe B</h3>
          <div class="row"><span class="label">Anzahl Teams</span><input type="number" id="countB" min="2" max="12"></div>
          <div id="namesB"></div>
        </div>
      </div>
      <div class="row" style="justify-content:flex-end; margin-top:12px; gap:10px">
        <button class="btn ghost" id="adminCancel">Verwerfen</button>
        <button class="btn" id="adminSave">Speichern & neu planen</button>
      </div>
      <div class="hint">Server‚ÄëSpeichern nur mit g√ºltigem Admin‚ÄëToken.</div>
    </section>
  </main>

  <nav class="bottom-nav" aria-label="Navigation">
    <button data-tab="plan" class="active">Spielplan</button>
    <button data-tab="tables">Tabellen</button>
    <button data-tab="ko">KO</button>
    <button data-tab="admin">Admin</button>
  </nav>

  <div id="overlay" class="overlay" role="dialog" aria-modal="true" aria-labelledby="qrTitle">
    <div class="qr-card">
      <div class="qr-grid">
        <h3 id="qrTitle" style="margin:0">üîó Teilen / QR-Code</h3>
        <img id="qrImg" alt="QR-Code zum √ñffnen">
        <div class="qr-row">
          <input type="text" id="shareLink" readonly>
          <button class="btn" id="copyBtn">Kopieren</button>
          <button class="btn ghost" id="closeOverlay">Schlie√üen</button>
        </div>
        <div class="hint">Tipp: Web Share (Android/iOS) ‚Äì wenn verf√ºgbar ‚Äì nutzt den nativen Share‚ÄëDialog.</div>
      </div>
    </div>
  </div>

<script>
// ===== URL mode handling =====
const params = new URLSearchParams(location.search);
const VIEW_PUBLIC = (params.get("view") === "public");
const modeBadge = document.getElementById("modeBadge");
if(VIEW_PUBLIC){
  modeBadge.textContent = "Zuschauermodus";
} else {
  modeBadge.textContent = "Admin/Editor";
}

// ===== Device density tweak =====
(function(){
  const coarse = window.matchMedia && window.matchMedia("(pointer: coarse)").matches;
  document.body.classList.toggle("pointer-fine", !coarse);
})();

// ===== Config =====
const TOURNAMENT_NAME = "TCO Doppelmaster 2025";
const TOURNAMENT_ID = "TCO%20Doppelmaster%202025"; // URL-encodet
const API = `/.netlify/functions/state?t=${TOURNAMENT_ID}`;
const USE_LOCAL_CACHE = true;

// ===== Admin-Token Handling =====
const KEY_TOKEN = "tco_admin_token";
let ADMIN_TOKEN = localStorage.getItem(KEY_TOKEN) || "";
const tokenInput = document.getElementById("adminTokenInput");
const tokenBtn = document.getElementById("saveTokenBtn");
tokenInput.value = ADMIN_TOKEN;
tokenBtn.addEventListener("click", ()=>{
  ADMIN_TOKEN = tokenInput.value.trim();
  localStorage.setItem(KEY_TOKEN, ADMIN_TOKEN);
  if(ADMIN_TOKEN){ setSyncStatus("üîì Admin‚ÄëToken gesetzt ‚Äì Server‚ÄëSpeichern aktiv", "ok"); }
  else { setSyncStatus("üîí Kein Admin‚ÄëToken ‚Äì keine Serverspeicherung", "err"); }
});

// In viewer mode: hide token UI & admin nav/tab
if(VIEW_PUBLIC){
  document.getElementById("adminTokenInput").style.display = "none";
  document.getElementById("saveTokenBtn").style.display = "none";
  document.querySelector('nav.bottom-nav button[data-tab="admin"]').style.display = "none";
  document.querySelector('#tabs button[data-tab="admin"]').style.display = "none";
  document.getElementById("admin").style.display = "none";
}

// ===== Helpers: Server Sync =====
const KEY_LOCAL = "tco_doppelmaster_state_publicqr";
const syncBadge = document.getElementById("syncBadge");
function setSyncStatus(text, cls=""){ syncBadge.textContent = text; syncBadge.className = "sync " + cls; }

async function serverLoad() {
  try {
    const res = await fetch(API, { method: "GET" });
    if(!res.ok) throw new Error("GET failed");
    const data = await res.json();
    setSyncStatus((ADMIN_TOKEN && !VIEW_PUBLIC) ? "‚úÖ Verbunden (Token bereit)" : "‚ÑπÔ∏è Verbunden (Nur Lesen)", (ADMIN_TOKEN && !VIEW_PUBLIC) ? "ok" : "");
    return data || {};
  } catch(e) {
    setSyncStatus("‚ö†Ô∏è Offline/Serverfehler", "err");
    return null;
  }
}
function withAuthHeaders(baseHeaders = {}){
  if(!ADMIN_TOKEN || VIEW_PUBLIC) throw new Error("NO_ADMIN_TOKEN");
  return { ...baseHeaders, "x-admin-token": ADMIN_TOKEN };
}
async function serverPatch(pathArray, value){
  const headers = withAuthHeaders({ "content-type": "application/json" });
  const res = await fetch(API, { method: "PATCH", headers, body: JSON.stringify({ path: pathArray, value }) });
  if(!res.ok) throw new Error("PATCH failed");
}

// ===== Local cache =====
function loadLocal(){ try { return JSON.parse(localStorage.getItem(KEY_LOCAL)) || {}; } catch { return {}; } }
function saveLocal(s){ try { localStorage.setItem(KEY_LOCAL, JSON.stringify(s)); } catch {} }
function resetLocal(){ localStorage.removeItem(KEY_LOCAL); }

// ===== App State =====
let state = {};

function defaultConfig(){
  return { groups: { A: ["A1","A2","A3","A4","A5"], B: ["B1","B2","B3","B4"] }, avoidFirstA5: true };
}
function ensureState(){
  if(!state.config) state.config = defaultConfig();
  if(!state.schedule) state.schedule = generateSchedule(state.config);
  if(!state.matches) state.matches = {};
  for(const [id] of state.schedule){
    if(!state.matches["g"+id]) state.matches["g"+id] = {sets1:"", sets2:"", games1:"", games2:""};
  }
  if(!state.KO) state.KO = { SF1:{t1:"A1", t2:"B2", s1:"", s2:""}, SF2:{t1:"B1", t2:"A2", s1:"", s2:""}, F:{t1:"", t2:"", s1:"", s2:""}, P3:{t1:"", t2:"", s1:"", s2:""} };
}

// ===== Round-Robin =====
function roundRobin(teams){
  const list = teams.slice();
  if(list.length % 2 === 1) list.push("BYE");
  const n = list.length, rounds = n-1, half = n/2;
  const out = [], arr = list.slice();
  for(let r=0; r<rounds; r++){
    const pairings = [];
    for(let i=0; i<half; i++){
      const t1 = arr[i], t2 = arr[n-1-i];
      if(t1!=="BYE" && t2!=="BYE") pairings.push([t1,t2]);
    }
    out.push(pairings);
    const fixed = arr[0], rest = arr.slice(1);
    rest.unshift(rest.pop()); arr.splice(0, arr.length, fixed, ...rest);
  }
  return out;
}
function generateSchedule(config){
  const A = config.groups.A.slice(), B = config.groups.B.slice();
  const rrA = roundRobin(A), rrB = roundRobin(B);
  if(config.avoidFirstA5 && rrA.length>0 && rrA[0].length>0){
    const lastA = A[A.length-1], firstPair = rrA[0][0];
    if(firstPair.includes(lastA)){
      for(let i=1;i<rrA[0].length;i++){
        if(!rrA[0][i].includes(lastA)){ const tmp = rrA[0][0]; rrA[0][0] = rrA[0][i]; rrA[0][i] = tmp; break; }
      }
    }
  }
  const totalRounds = Math.max(rrA.length, rrB.length);
  const schedule = []; let id = 1;
  for(let r=0; r<totalRounds; r++){
    const aPairs = rrA[r] || [], bPairs = rrB[r] || [];
    for(let i=0;i<2;i++){ if(aPairs[i]) schedule.push([id++, `Runde ${r+1}`, `Platz ${i+1}`, aPairs[i][0], aPairs[i][1], 'A']); }
    for(let i=0;i<2;i++){ if(bPairs[i]) schedule.push([id++, `Runde ${r+1}`, `Platz ${i+3}`, bPairs[i][0], bPairs[i][1], 'B']); }
  }
  return schedule;
}

// ===== Rendering (inputs disabled in public mode) =====
function renderSchedule(){
  const wrap = document.getElementById("schedule");
  wrap.innerHTML = "";
  const sched = state.schedule;
  const narrow = window.matchMedia && window.matchMedia("(max-width: 720px)").matches;

  const rounds = {};
  for(const m of sched){ const r = m[1]; if(!rounds[r]) rounds[r] = []; rounds[r].push(m); }
  Object.keys(rounds).forEach((round,i)=>{
    let rwrap;
    if(narrow){
      const box = document.createElement("div");
      box.className = "accordion" + (i===0 ? " acc-open" : "");
      box.innerHTML = `
        <div class="acc-head">
          <div class="row"><h3 style="margin:0">${round}</h3><span class="badge">bis 4 Pl√§tze</span></div>
          <span class="chev">‚åÉ</span>
        </div>
        <div class="acc-body"><div class="grid cols-2" id="round_${i}"></div></div>`;
      box.querySelector(".acc-head").addEventListener("click", ()=> box.classList.toggle("acc-open"));
      wrap.appendChild(box);
      rwrap = box.querySelector("#round_"+i);
    } else {
      const r = document.createElement("div");
      r.className = "card"; r.style.margin = "12px 0";
      r.innerHTML = `<div class="row" style="justify-content:space-between; align-items:center">
        <div class="row"><h3 style="margin:0">${round}</h3><span class="badge">Parallel: bis zu 4 Pl√§tze</span></div>
        <span class="muted">ab Spiel #${rounds[round][0][0]}</span>
      </div>`;
      const rwrapDiv = document.createElement("div"); rwrapDiv.className = "grid cols-2";
      r.appendChild(rwrapDiv); wrap.appendChild(r); rwrap = rwrapDiv;
    }

    rounds[round].forEach(([id, , court, t1, t2, grp])=>{
      const m = state.matches["g"+id] || {sets1:"", sets2:"", games1:"", games2:""};
      const card = document.createElement("div");
      card.className = "match-card";
      card.innerHTML = `
        <div class="title">#${id} ¬∑ ${court} ¬∑ Gruppe ${grp}</div>
        <div class="team-row">
          <span class="name">${t1}</span>
          <div class="row">
            <label class="muted">S√§tze</label>
            <input ${VIEW_PUBLIC ? "disabled" : ""} inputmode="numeric" pattern="[0-9]*" type="number" min="0" step="1" id="s1_${id}" value="${m.sets1}">
            <label class="muted">Spiele</label>
            <input ${VIEW_PUBLIC ? "disabled" : ""} inputmode="numeric" pattern="[0-9]*" type="number" min="0" step="1" id="g1_${id}" value="${m.games1}">
          </div>
        </div>
        <div class="team-row">
          <span class="name">${t2}</span>
          <div class="row">
            <label class="muted">S√§tze</label>
            <input ${VIEW_PUBLIC ? "disabled" : ""} inputmode="numeric" pattern="[0-9]*" type="number" min="0" step="1" id="s2_${id}" value="${m.sets2}">
            <label class="muted">Spiele</label>
            <input ${VIEW_PUBLIC ? "disabled" : ""} inputmode="numeric" pattern="[0-9]*" type="number" min="0" step="1" id="g2_${id}" value="${m.games2}">
          </div>
        </div>
        <div class="row" style="justify-content:flex-end; gap:8px">
          ${VIEW_PUBLIC ? "" : `<button class="btn ghost" id="clear_${id}">L√∂schen</button>`}
        </div>`;
      rwrap.appendChild(card);

      if(!VIEW_PUBLIC){
        function bind(idStr, key){
          const el = document.getElementById(idStr);
          if(!el) return;
          el.addEventListener("input", async (e)=>{
            state.matches["g"+id] = state.matches["g"+id] || {sets1:"", sets2:"", games1:"", games2:""};
            state.matches["g"+id][key] = e.target.value;
            if(USE_LOCAL_CACHE) saveLocal(state);
            try { await serverPatch(["matches","g"+id], state.matches["g"+id]); setSyncStatus("‚úÖ Synchronisiert", "ok"); }
            catch (ex) {
              if(String(ex).includes("NO_ADMIN_TOKEN")) setSyncStatus("üîí Kein Admin‚ÄëToken ‚Äì lokal gespeichert, nicht am Server", "err");
              else setSyncStatus("‚ö†Ô∏è Nicht synchronisiert (Serverfehler) ‚Äì lokal zwischengespeichert", "err");
            }
            updateTables(); renderKO(); updateKPIs();
          });
        }
        bind(`s1_${id}`, "sets1"); bind(`s2_${id}`, "sets2"); bind(`g1_${id}`, "games1"); bind(`g2_${id}`, "games2");
        const clr = document.getElementById(`clear_${id}`);
        if(clr) clr.addEventListener("click", async ()=>{
          state.matches["g"+id] = {sets1:"", sets2:"", games1:"", games2:""};
          if(USE_LOCAL_CACHE) saveLocal(state);
          try{ await serverPatch(["matches","g"+id], state.matches["g"+id]); setSyncStatus("‚úÖ Synchronisiert","ok"); }
          catch(ex){
            if(String(ex).includes("NO_ADMIN_TOKEN")) setSyncStatus("üîí Kein Admin‚ÄëToken ‚Äì lokal gel√∂scht, nicht am Server","err");
            else setSyncStatus("‚ö†Ô∏è Nicht synchronisiert (Serverfehler) ‚Äì lokal zwischengespeichert","err");
          }
          renderSchedule(); updateTables(); renderKO(); updateKPIs();
        });
      }
    });
  });
}

function isNumber(x){ return x!=="" && !isNaN(Number(x)); }

function computeStandings(){
  const groups = state.config.groups;
  const standings = { A:{}, B:{} };
  for(const g of ["A","B"]){
    for(const t of groups[g]) standings[g][t] = {Team:t, GP:0, W:0, L:0, SetsPlus:0, SetsMinus:0, GamesPlus:0, GamesMinus:0, Pts:0};
  }
  const h2h = {A:{}, B:{}}; for(const g of ["A","B"]){ for(const t of groups[g]) h2h[g][t] = {}; }

  state.schedule.forEach(([id, , , t1, t2, grp])=>{
    const r = state.matches["g"+id] || {};
    const s1 = Number(r.sets1), s2 = Number(r.sets2);
    const g1 = Number(r.games1), g2 = Number(r.games2);
    const haveSets = isNumber(r.sets1) && isNumber(r.sets2);
    const haveGames = isNumber(r.games1) && isNumber(r.games2);
    if(!haveSets) return;
    standings[grp][t1].GP++; standings[grp][t2].GP++;
    standings[grp][t1].SetsPlus += s1; standings[grp][t1].SetsMinus += s2;
    standings[grp][t2].SetsPlus += s2; standings[grp][t2].SetsMinus += s1;
    if(haveGames){
      standings[grp][t1].GamesPlus += g1; standings[grp][t1].GamesMinus += g2;
      standings[grp][t2].GamesPlus += g2; standings[grp][t2].GamesMinus += g1;
    }
    if(s1>s2){ standings[grp][t1].W++; standings[grp][t2].L++; standings[grp][t1].Pts++; }
    else if(s2>s1){ standings[grp][t2].W++; standings[grp][t1].L++; standings[grp][t2].Pts++; }
    const winner = s1===s2 ? null : (s1>s2 ? t1 : t2);
    const loser  = s1===s2 ? null : (s1>s2 ? t2 : t1);
    if(winner && loser){ h2h[grp][winner][loser] = (h2h[grp][winner][loser] || 0) + 1; }
  });

  function sortGroup(grp){
    const arr = Object.values(standings[grp]);
    arr.sort((a,b)=>{
      const p = b.Pts - a.Pts; if(p) return p;
      const sd = (b.SetsPlus-b.SetsMinus) - (a.SetsPlus-a.SetsMinus); if(sd) return sd;
      const gd = (b.GamesPlus-b.GamesMinus) - (a.GamesPlus-a.GamesMinus) ; if(gd) return gd;
      const h = ((a.Team in h2h[grp] && b.Team in h2h[grp][a.Team]) ? h2h[grp][a.Team][b.Team] : 0)
              - ((b.Team in h2h[grp] && a.Team in h2h[grp][b.Team]) ? h2h[grp][b.Team][a.Team] : 0);
      if(h) return -h;
      return a.Team.localeCompare(b.Team);
    });
    arr.forEach((r,i)=> r.Rang = i+1);
    return arr;
  }
  return {A: sortGroup("A"), B: sortGroup("B")};
}

function tableHTML(rows){
  return `
  <table>
    <thead>
      <tr>
        <th>#</th><th>Team</th><th>Spiele</th><th>Siege</th><th>Niederl.</th>
        <th>S√§tze +/‚àí</th><th>Spiele +/‚àí</th><th>Punkte</th>
      </tr>
    </thead>
    <tbody>
      ${rows.map(r=>`
        <tr>
          <td>${r.Rang}</td>
          <td>${r.Team}</td>
          <td>${r.GP}</td>
          <td>${r.W}</td>
          <td>${r.L}</td>
          <td>${r.SetsPlus}:${r.SetsMinus} (${r.SetsPlus - r.SetsMinus})</td>
          <td>${r.GamesPlus}:${r.GamesMinus} (${r.GamesPlus - r.GamesMinus})</td>
          <td>${r.Pts}</td>
        </tr>
      `).join("")}
    </tbody>
  </table>`;
}

function updateTables(){
  const {A, B} = computeStandings();
  document.getElementById("tableA").innerHTML = tableHTML(A);
  document.getElementById("tableB").innerHTML = tableHTML(B);
}

function allGroupFinished(grp){
  const total = state.schedule.filter(s=>s[5]===grp).length;
  let have = 0;
  state.schedule.forEach(([id, , , , , g])=>{
    const r = state.matches["g"+id] || {};
    if(g===grp && isNumber(r.sets1) && isNumber(r.sets2)) have++;
  });
  return have === total && total>0;
}

function renderKO(){
  const br = document.getElementById("koBracket");
  br.innerHTML = "";
  const finishedA = allGroupFinished("A");
  const finishedB = allGroupFinished("B");
  const ready = finishedA && finishedB;
  const {A, B} = computeStandings();
  const A1 = A[0]?.Team, A2 = A[1]?.Team;
  const B1 = B[0]?.Team, B2 = B[1]?.Team;
  const K = state.KO;
  if(ready){
    K.SF1.t1 = A1; K.SF1.t2 = B2;
    K.SF2.t1 = B1; K.SF2.t2 = A2;
    const winner = (m)=> (m.s1===""||m.s2==="") ? null : (Number(m.s1)>Number(m.s2)? m.t1 : m.t2);
    const loser  = (m)=> (m.s1===""||m.s2==="") ? null : (Number(m.s1)>Number(m.s2)? m.t2 : m.t1);
    const w1 = winner(K.SF1), w2 = winner(K.SF2);
    const l1 = loser(K.SF1), l2 = loser(K.SF2);
    if(w1 && w2){ K.F.t1 = w1; K.F.t2 = w2; }
    if(l1 && l2){ K.P3.t1 = l1; K.P3.t2 = l2; }
  }
  function matchCard(key, title){
    const m = K[key];
    const el = document.createElement("div");
    el.className = "match-card";
    el.innerHTML = `
      <div class="title">${title}</div>
      <div class="team-row">
        <span class="name">${m.t1 || "‚Äî"}</span>
        <div class="row"><label class="muted">S√§tze</label>
          <input ${VIEW_PUBLIC ? "disabled" : ""} inputmode="numeric" pattern="[0-9]*" type="number" min="0" step="1" id="${key}_s1" value="${m.s1}">
        </div>
      </div>
      <div class="team-row">
        <span class="name">${m.t2 || "‚Äî"}</span>
        <div class="row"><label class="muted">S√§tze</label>
          <input ${VIEW_PUBLIC ? "disabled" : ""} inputmode="numeric" pattern="[0-9]*" type="number" min="0" step="1" id="${key}_s2" value="${m.s2}">
        </div>
      </div>
      <div class="hint">${ready? "Automatisch aus Gruppentabellen bef√ºllt." : "Wartet auf Abschluss der Gruppenphase."}</div>
    `;
    setTimeout(()=>{
      if(VIEW_PUBLIC) return;
      const s1 = document.getElementById(`${key}_s1`);
      const s2 = document.getElementById(`${key}_s2`);
      if(s1) s1.addEventListener("input", async (e)=>{
        state.KO[key].s1 = e.target.value;
        if(USE_LOCAL_CACHE) saveLocal(state);
        try{ await serverPatch(["KO", key], state.KO[key]); setSyncStatus("‚úÖ Synchronisiert","ok"); }
        catch(ex){
          if(String(ex).includes("NO_ADMIN_TOKEN")) setSyncStatus("üîí Kein Admin‚ÄëToken ‚Äì lokal gespeichert, nicht am Server","err");
          else setSyncStatus("‚ö†Ô∏è Nicht synchronisiert (Serverfehler) ‚Äì lokal zwischengespeichert","err");
        }
        renderKO();
      });
      if(s2) s2.addEventListener("input", async (e)=>{
        state.KO[key].s2 = e.target.value;
        if(USE_LOCAL_CACHE) saveLocal(state);
        try{ await serverPatch(["KO", key], state.KO[key]); setSyncStatus("‚úÖ Synchronisiert","ok"); }
        catch(ex){
          if(String(ex).includes("NO_ADMIN_TOKEN")) setSyncStatus("üîí Kein Admin‚ÄëToken ‚Äì lokal gespeichert, nicht am Server","err");
          else setSyncStatus("‚ö†Ô∏è Nicht synchronisiert (Serverfehler) ‚Äì lokal zwischengespeichert","err");
        }
        renderKO();
      });
    }, 0);
    return el;
  }
  const col1 = document.createElement("div");
  const col2 = document.createElement("div");
  col1.appendChild(matchCard("SF1","Halbfinale 1 (A1 vs B2)"));
  col2.appendChild(matchCard("SF2","Halbfinale 2 (B1 vs A2)"));
  col1.appendChild(matchCard("P3","Spiel um Platz 3"));
  col2.appendChild(matchCard("F","Finale"));
  br.appendChild(col1); br.appendChild(col2);
}

function updateKPIs(){
  const played = Object.keys(state.matches||{}).filter(k=>{
    const r = state.matches[k]; return isNumber(r?.sets1)&&isNumber(r?.sets2);
  }).length;
  const total = state.schedule.length;
  const doneA = allGroupFinished("A");
  const doneB = allGroupFinished("B");
  const kpis = document.getElementById("kpis");
  kpis.innerHTML = `
    <div class="tile"><div class="label">Turnier</div><div class="value">${TOURNAMENT_NAME}</div></div>
    <div class="tile"><div class="label">Teams A/B</div><div class="value">${state.config.groups.A.length} / ${state.config.groups.B.length}</div></div>
    <div class="tile"><div class="label">Gespielte Spiele</div><div class="value">${played}/${total}</div></div>
    <div class="tile"><div class="label">A/B Status</div><div class="value">${doneA? "A: fertig" : "A: l√§uft"} ¬∑ ${doneB? "B: fertig" : "B: l√§uft"}</div></div>
  `;
}

// ===== Admin UI (hidden in public mode) =====
function renderAdmin(){
  if(VIEW_PUBLIC) return;
  const cfg = state.config;
  const countA = document.getElementById("countA");
  const countB = document.getElementById("countB");
  const namesA = document.getElementById("namesA");
  const namesB = document.getElementById("namesB");
  const avoid = document.getElementById("avoidFirstA5");
  countA.value = cfg.groups.A.length; countB.value = cfg.groups.B.length; avoid.checked = !!cfg.avoidFirstA5;

  function renderNames(container, arr, prefix){
    container.innerHTML = "";
    arr.forEach((name, idx)=>{
      const row = document.createElement("div"); row.className = "row";
      row.innerHTML = `<span class="label" style="width:72px">${prefix}${idx+1}</span>
        <input type="text" value="${name}" id="${prefix}${idx+1}_name" style="flex:1; min-width:160px">`;
      container.appendChild(row);
    });
  }
  renderNames(namesA, cfg.groups.A, "A"); renderNames(namesB, cfg.groups.B, "B");

  function adjustCount(which, newCount){
    const list = cfg.groups[which]; const current = list.length;
    if(newCount>current){ for(let i=current; i<newCount; i++){ list.push(`${which}${i+1}`); } }
    else if(newCount<current){ list.splice(newCount); }
  }
  countA.oninput = ()=>{ const n = Math.max(2, Math.min(12, Number(countA.value)||2)); adjustCount("A", n); renderAdmin(); };
  countB.oninput = ()=>{ const n = Math.max(2, Math.min(12, Number(countB.value)||2)); adjustCount("B", n); renderAdmin(); };

  document.getElementById("adminCancel").onclick = ()=>{ renderAdmin(); };

  document.getElementById("adminSave").onclick = async ()=>{
    const newA = [], newB = [];
    for(let i=0;i<cfg.groups.A.length;i++){ newA.push((document.getElementById(`A${i+1}_name`).value || `A${i+1}`).trim()); }
    for(let i=0;i<cfg.groups.B.length;i++){ newB.push((document.getElementById(`B${i+1}_name`).value || `B${i+1}`).trim()); }
    cfg.groups.A = newA; cfg.groups.B = newB; cfg.avoidFirstA5 = document.getElementById("avoidFirstA5").checked;

    const newSchedule = generateSchedule(cfg);
    const newMatches = {};
    for(const [id] of newSchedule){ newMatches["g"+id] = state.matches["g"+id] || {sets1:"", sets2:"", games1:"", games2:""}; }
    state.schedule = newSchedule; state.matches = newMatches;
    state.KO = { SF1:{t1:"",t2:"",s1:"",s2:""}, SF2:{t1:"",t2:"",s1:"",s2:""}, F:{t1:"",t2:"",s1:"",s2:""}, P3:{t1:"",t2:"",s1:"",s2:""} };

    if(USE_LOCAL_CACHE) saveLocal(state);
    try{
      await serverPatch(["config"], cfg);
      await serverPatch(["schedule"], newSchedule);
      await serverPatch(["matches"], newMatches);
      await serverPatch(["KO"], state.KO);
      setSyncStatus("‚úÖ Synchronisiert", "ok");
    }catch(ex){
      if(String(ex).includes("NO_ADMIN_TOKEN")) setSyncStatus("üîí Kein Admin‚ÄëToken ‚Äì lokal gespeichert, nicht am Server", "err");
      else setSyncStatus("‚ö†Ô∏è Nicht synchronisiert (Serverfehler) ‚Äì lokal zwischengespeichert", "err");
    }
    renderSchedule(); updateTables(); renderKO(); updateKPIs(); renderAdmin();
  };
}

// ===== Tabs (bottom nav + header tabs for desktop/tablet) =====
function activateTab(name){
  document.querySelectorAll(".tab").forEach(x=>x.classList.toggle("active", x.dataset.tab===name));
  document.querySelectorAll(".bottom-nav button").forEach(x=>x.classList.toggle("active", x.dataset.tab===name));
  document.querySelectorAll("main section").forEach(s=> s.style.display="none");
  document.getElementById(name).style.display = "";
  window.scrollTo({ top: 0, behavior: "smooth" });
}
document.querySelectorAll(".tab").forEach(t=> t.addEventListener("click", ()=> activateTab(t.dataset.tab)));
document.querySelectorAll(".bottom-nav button").forEach(b=> b.addEventListener("click", ()=> activateTab(b.dataset.tab)));

// ===== QR Overlay & Sharing =====
const overlay = document.getElementById("overlay");
const qrBtn = document.getElementById("qrBtn");
const qrImg = document.getElementById("qrImg");
const shareLink = document.getElementById("shareLink");
const closeOverlay = document.getElementById("closeOverlay");
const copyBtn = document.getElementById("copyBtn");

function buildPublicURL(){
  const url = new URL(location.href);
  url.searchParams.set("view", "public");
  return url.toString();
}
function openQR(){
  const link = buildPublicURL();
  shareLink.value = link;
  const qrURL = "https://api.qrserver.com/v1/create-qr-code/?size=480x480&margin=8&data=" + encodeURIComponent(link);
  qrImg.src = qrURL;
  overlay.classList.add("open");
}
function closeQR(){ overlay.classList.remove("open"); }
qrBtn.addEventListener("click", ()=>{
  // Try Web Share first
  const link = buildPublicURL();
  if(navigator.share){
    navigator.share({ title: "TCO Doppelmaster 2025 ‚Äì Live", text: "Live‚ÄëTabelle & Spielplan", url: link })
      .catch(()=> openQR());
  }else{
    openQR();
  }
});
closeOverlay.addEventListener("click", closeQR);
copyBtn.addEventListener("click", async ()=>{
  try{ await navigator.clipboard.writeText(shareLink.value); copyBtn.textContent = "Kopiert!"; setTimeout(()=>copyBtn.textContent="Kopieren", 1500);}catch{}
});
overlay.addEventListener("click", (e)=>{ if(e.target === overlay) closeQR(); });

// ===== Export =====
document.getElementById("downloadJson").addEventListener("click", ()=>{
  const blob = new Blob([JSON.stringify(state, null, 2)], {type:"application/json"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a"); a.href = url; a.download = "tco_doppelmaster_state.json"; a.click();
  setTimeout(()=>URL.revokeObjectURL(url), 1500);
});

// ===== Boot =====
(async function boot(){
  const data = await serverLoad();
  if(data){ state = data; } else if(USE_LOCAL_CACHE){ state = loadLocal(); } else { state = {}; }
  ensureState(); if(USE_LOCAL_CACHE) saveLocal(state);
  renderSchedule(); updateTables(); renderKO(); updateKPIs(); renderAdmin();
  if(ADMIN_TOKEN && !VIEW_PUBLIC){ setSyncStatus("üîì Admin‚ÄëToken gesetzt ‚Äì Server‚ÄëSpeichern aktiv", "ok"); }
  else { setSyncStatus("üîí Nur Lesen (Zuschauermodus oder kein Token)", ""); }
})();
</script>
</body>
</html>
