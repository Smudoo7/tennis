
<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>TCO Doppelmaster 2025 ‚Äì Live-Dashboard</title>
<style>
  :root{
    --bg: #0f1220;
    --card: #15192e;
    --muted: #8b91a7;
    --text: #e7e9f3;
    --accent: #6ee7b7;
    --accent-2: #60a5fa;
    --danger: #f87171;
    --warn: #fbbf24;
    --shadow: 0 10px 30px rgba(0,0,0,.35);
    --radius: 16px;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
    background: radial-gradient(1200px 800px at 20% -10%, #1b2146 0%, #12162a 50%, #0d1020 100%);
    color:var(--text);
    line-height:1.45;
  }
  header{
    position:sticky; top:0; z-index:10;
    backdrop-filter: blur(10px);
    background: rgba(15,18,32,.7);
    padding:12px 16px; border-bottom:1px solid #1f2446;
  }
  .container{max-width:1200px; margin:0 auto; padding:16px}
  h1{font-size:clamp(22px, 3vw, 32px); margin:6px 0 4px}
  .sub{color:var(--muted); font-size:14px}
  .grid{display:grid; gap:16px}
  .grid.cols-3{grid-template-columns: repeat(3, minmax(0,1fr));}
  .grid.cols-2{grid-template-columns: repeat(2, minmax(0,1fr));}
  @media (max-width: 1024px){
    .grid.cols-3{grid-template-columns: 1fr;}
    .grid.cols-2{grid-template-columns: 1fr;}
  }
  .tabs{display:flex; gap:8px; flex-wrap:wrap; margin:16px 0}
  .tab{
    padding:10px 14px; border:1px solid #26305f; border-radius:999px; cursor:pointer;
    color:var(--muted); background:#0f142a; transition:.2s;
  }
  .tab.active{color:#0c1326; background:linear-gradient(135deg, var(--accent), var(--accent-2)); border-color:transparent; font-weight:600}
  .card{
    background: linear-gradient(180deg, rgba(255,255,255,.02), transparent) , var(--card);
    border:1px solid #222a52;
    border-radius: var(--radius);
    box-shadow: var(--shadow);
    padding:16px;
  }
  .card h2{margin:0 0 10px; font-size:18px}
  .muted{color:var(--muted)}
  .row{display:flex; gap:12px; align-items:center; flex-wrap:wrap}
  .badge{
    padding:4px 8px; font-size:12px; border-radius:999px; border:1px solid #2d3666; color:var(--muted);
    background:#0f142a;
  }
  table{width:100%; border-collapse:collapse; font-size:14px; overflow:hidden; border-radius:12px}
  thead th{
    text-align:left; font-weight:600; color:#aab2d8; background:#0f142a; border-bottom:1px solid #26305f;
    padding:10px 8px;
  }
  tbody td{padding:10px 8px; border-bottom:1px dashed #253060}
  tbody tr:hover{background:#10163a}
  .kpi{display:flex; gap:12px; flex-wrap:wrap}
  .kpi .tile{
    flex:1 1 160px;
    background: radial-gradient(400px 200px at 120% -20%, rgba(96,165,250,.2), transparent 70%) , #121734;
    border:1px solid #23306a; border-radius:16px; padding:14px;
  }
  .tile .label{font-size:12px; color:var(--muted)}
  .tile .value{font-size:22px; font-weight:700}
  input[type="number"]{
    width:60px; background:#0e1431; border:1px solid #2b3568; color:var(--text); border-radius:10px; padding:6px 8px;
  }
  .btn{
    appearance:none; border:none; border-radius:12px; padding:10px 14px; cursor:pointer;
    color:#0b1225; background:linear-gradient(135deg, var(--accent), var(--accent-2)); font-weight:700;
    box-shadow: 0 8px 20px rgba(96,165,250,.25);
  }
  .btn.ghost{background:#0f142a; color:var(--text); border:1px solid #273063; box-shadow:none}
  .pill{display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border-radius:999px; background:#0f142a; border:1px solid #2b3568; color:var(--muted); font-size:12px}
  .split{display:grid; grid-template-columns: 1fr 1fr; gap:16px}
  @media (max-width: 900px){ .split{grid-template-columns: 1fr;} }
  .bracket{display:grid; grid-template-columns: 1fr 1fr 1fr; gap:16px}
  .match-card{border:1px solid #2d376b; border-radius:14px; padding:10px; background:#0f142a}
  .match-card .title{color:#a8b2e2; font-size:12px; margin-bottom:8px}
  .team-row{display:flex; align-items:center; justify-content:space-between; gap:8px; margin:6px 0}
  .team-row .name{font-weight:600}
  .team-row input{width:64px}
  .winner{color:var(--accent)}
  .loser{color:var(--muted)}
  .footer{margin-top:24px; color:var(--muted); font-size:12px}
  .hint{font-size:12px; color:var(--muted)}
  .sync{display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border-radius:999px; border:1px solid #2b3568; background:#0f142a; color:var(--muted); font-size:12px}
  .sync.ok{color:#10b981}
  .sync.err{color:#f87171}
</style>
</head>
<body>
  <header>
    <div class="container">
      <div class="row" style="justify-content:space-between; align-items:center">
        <div>
          <h1>üèÜ TCO Doppelmaster 2025 ‚Äì Gruppenphase & KO</h1>
          <div class="sub">4 Pl√§tze ¬∑ Gruppe A auf Platz 1‚Äì2 ¬∑ Gruppe B auf Platz 3‚Äì4 ¬∑ A5 hat nicht das erste Spiel</div>
        </div>
        <div class="row">
          <span id="syncBadge" class="sync">üîÑ Verbinden‚Ä¶</span>
          <button class="btn" id="downloadJson">Ergebnisse exportieren</button>
          <button class="btn ghost" id="resetAll">Lokal zur√ºcksetzen</button>
        </div>
      </div>
      <div class="kpi" id="kpis"></div>
      <div class="tabs" id="tabs">
        <button class="tab active" data-tab="plan">Spielplan</button>
        <button class="tab" data-tab="tables">Live‚ÄëTabellen</button>
        <button class="tab" data-tab="ko">KO‚ÄëPhase</button>
      </div>
    </div>
  </header>

  <main class="container">
    <section id="plan" class="card">
      <div class="row" style="justify-content:space-between">
        <h2>üóìÔ∏è Spielplan (Gruppenphase)</h2>
        <span class="pill">Server‚ÄëSync + lokaler Cache</span>
      </div>
      <div class="hint">Trage S√§tze und (optional) Spiele ein. Ranking: Siege ‚Üí Satzdiff ‚Üí Spieldiff ‚Üí Direktvergleich.</div>
      <div id="schedule"></div>
    </section>

    <section id="tables" class="card" style="display:none">
      <h2>üìä Live‚ÄëTabellen</h2>
      <div class="split">
        <div>
          <div class="row"><h3>Gruppe A</h3><span class="badge">Platz 1‚Äì2</span></div>
          <div id="tableA"></div>
        </div>
        <div>
          <div class="row"><h3>Gruppe B</h3><span class="badge">Platz 3‚Äì4</span></div>
          <div id="tableB"></div>
        </div>
      </div>
    </section>

    <section id="ko" class="card" style="display:none">
      <h2>ü•á KO‚ÄëPhase</h2>
      <div class="hint">Wird automatisch bef√ºllt, sobald beide Gruppen fertig sind.</div>
      <div id="koBracket" class="bracket"></div>
    </section>

    <div class="footer">Hinweis: Speicherung zentral √ºber Netlify Functions (Blobs). Lokaler Fallback via Browser‚ÄëCache.</div>
  </main>

<script>
// ===== Konfiguration ‚Äì anpassen =====
const TOURNAMENT_NAME = "TCO Doppelmaster 2025";
const TOURNAMENT_ID = "TCO%20Doppelmaster%202025"; // URL-encodet
const API = `/.netlify/functions/state?t=${TOURNAMENT_ID}`;
// Optional: wenn du ein Admin-Token gesetzt hast (Netlify ENV ADMIN_TOKEN)
const ADMIN_TOKEN = "admin"; // z.B. "mein-geheimes-token"
const USE_LOCAL_CACHE = true;

// ===== Gruppen & Spielplan =====
const GROUPS = { "A": ["A1","A2","A3","A4","A5"], "B": ["B1","B2","B3","B4"] };
const SCHEDULE = [
 [1, 'Runde 1', 'Platz 1', 'A3', 'A4', 'A'],
 [2, 'Runde 1', 'Platz 2', 'A2', 'A5', 'A'],
 [3, 'Runde 1', 'Platz 3', 'B1', 'B4', 'B'],
 [4, 'Runde 1', 'Platz 4', 'B2', 'B3', 'B'],
 [5, 'Runde 2', 'Platz 1', 'A1', 'A5', 'A'],
 [6, 'Runde 2', 'Platz 2', 'A2', 'A3', 'A'],
 [7, 'Runde 2', 'Platz 3', 'B1', 'B3', 'B'],
 [8, 'Runde 2', 'Platz 4', 'B4', 'B2', 'B'],
 [9, 'Runde 3', 'Platz 1', 'A1', 'A4', 'A'],
 [10, 'Runde 3', 'Platz 2', 'A5', 'A3', 'A'],
 [11, 'Runde 3', 'Platz 3', 'B1', 'B2', 'B'],
 [12, 'Runde 3', 'Platz 4', 'B3', 'B4', 'B'],
 [13, 'Runde 4', 'Platz 1', 'A1', 'A3', 'A'],
 [14, 'Runde 4', 'Platz 2', 'A4', 'A2', 'A'],
 [15, 'Runde 5', 'Platz 1', 'A1', 'A2', 'A'],
 [16, 'Runde 5', 'Platz 2', 'A4', 'A5', 'A']
];

// ===== Helper: Server Sync (Netlify Blobs) =====
const KEY_LOCAL = "tennis_dashboard_cache_v2";
const syncBadge = document.getElementById("syncBadge");
function setSyncStatus(text, cls=""){ syncBadge.textContent = text; syncBadge.className = "sync " + cls; }

async function serverLoad() {
  try {
    const res = await fetch(API, { method: "GET" });
    if(!res.ok) throw new Error("GET failed");
    const data = await res.json();
    setSyncStatus("‚úÖ Verbunden", "ok");
    return data || {};
  } catch(e) {
    setSyncStatus("‚ö†Ô∏è Offline/Serverfehler", "err");
    return null;
  }
}

async function serverSaveFull(state) {
  const headers = { "content-type": "application/json" };
  if(ADMIN_TOKEN) headers["x-admin-token"] = ADMIN_TOKEN;
  const res = await fetch(API, { method: "PUT", headers, body: JSON.stringify(state) });
  if(!res.ok) throw new Error("PUT failed");
}
async function serverPatch(pathArray, value) {
  const headers = { "content-type": "application/json" };
  if(ADMIN_TOKEN) headers["x-admin-token"] = ADMIN_TOKEN;
  const res = await fetch(API, { method: "PATCH", headers, body: JSON.stringify({ path: pathArray, value }) });
  if(!res.ok) throw new Error("PATCH failed");
}

// ===== Lokaler Cache (Optional) =====
function loadLocal(){ try { return JSON.parse(localStorage.getItem(KEY_LOCAL)) || {}; } catch { return {}; } }
function saveLocal(s){ try { localStorage.setItem(KEY_LOCAL, JSON.stringify(s)); } catch {} }
function resetLocal(){ localStorage.removeItem(KEY_LOCAL); }

// ===== App State =====
let state = {}; // { matches: { g1:{...}, ... }, KO:{...} }

function ensureState(){
  if(!state.matches) state.matches = {};
  for(const [id] of SCHEDULE){
    if(!state.matches["g"+id]) state.matches["g"+id] = {sets1:"", sets2:"", games1:"", games2:""};
  }
  if(!state.KO) state.KO = {
    SF1:{t1:"A1", t2:"B2", s1:"", s2:""},
    SF2:{t1:"B1", t2:"A2", s1:"", s2:""},
    F:{t1:"", t2:"", s1:"", s2:""},
    P3:{t1:"", t2:"", s1:"", s2:""}
  };
}

function isNumber(x){ return x !== "" && !isNaN(Number(x)); }

// ===== Rendering =====
function renderSchedule(){
  const wrap = document.getElementById("schedule");
  wrap.innerHTML = "";
  let currentRound = "";
  let groupWrap = null;
  SCHEDULE.forEach(([id, round, court, t1, t2, grp], idx) => {
    if(round !== currentRound){
      currentRound = round;
      const r = document.createElement("div");
      r.className = "card";
      r.style.margin = "12px 0";
      r.innerHTML = `<div class="row" style="justify-content:space-between; align-items:center">
        <div class="row"><h3 style="margin:0">${round}</h3><span class="badge">Parallel: 4 Pl√§tze</span></div>
        <span class="muted">Spiele ${id}‚Äì${Math.min(id+3, SCHEDULE.length)}</span>
      </div>`;
      groupWrap = document.createElement("div");
      groupWrap.className = "grid cols-2";
      r.appendChild(groupWrap);
      wrap.appendChild(r);
    }
    const m = state.matches["g"+id];
    const card = document.createElement("div");
    card.className = "match-card";
    card.innerHTML = `
      <div class="title">#${id} ¬∑ ${court} ¬∑ Gruppe ${grp}</div>
      <div class="team-row">
        <span class="name">${t1}</span>
        <div class="row">
          <label class="muted">S√§tze</label>
          <input type="number" min="0" step="1" id="s1_${id}" value="${m.sets1}">
          <label class="muted">Spiele</label>
          <input type="number" min="0" step="1" id="g1_${id}" value="${m.games1}">
        </div>
      </div>
      <div class="team-row">
        <span class="name">${t2}</span>
        <div class="row">
          <label class="muted">S√§tze</label>
          <input type="number" min="0" step="1" id="s2_${id}" value="${m.sets2}">
          <label class="muted">Spiele</label>
          <input type="number" min="0" step="1" id="g2_${id}" value="${m.games2}">
        </div>
      </div>
      <div class="row" style="justify-content:flex-end">
        <button class="btn ghost" id="clear_${id}">L√∂schen</button>
      </div>
    `;
    groupWrap.appendChild(card);

    function bind(idStr, key){
      document.getElementById(idStr).addEventListener("input", async (e)=>{
        state.matches["g"+id][key] = e.target.value;
        if(USE_LOCAL_CACHE) saveLocal(state);
        try {
          await serverPatch(["matches", "g"+id], state.matches["g"+id]);
          setSyncStatus("‚úÖ Synchronisiert", "ok");
        } catch {
          setSyncStatus("‚ö†Ô∏è Nicht synchronisiert (lokal zwischengespeichert)", "err");
        }
        updateTables();
        renderKO();
        updateKPIs();
      });
    }
    bind(`s1_${id}`, "sets1");
    bind(`s2_${id}`, "sets2");
    bind(`g1_${id}`, "games1");
    bind(`g2_${id}`, "games2");
    document.getElementById(`clear_${id}`).addEventListener("click", async ()=>{
      state.matches["g"+id] = {sets1:"", sets2:"", games1:"", games2:""};
      if(USE_LOCAL_CACHE) saveLocal(state);
      try {
        await serverPatch(["matches", "g"+id], state.matches["g"+id]);
        setSyncStatus("‚úÖ Synchronisiert", "ok");
      } catch {
        setSyncStatus("‚ö†Ô∏è Nicht synchronisiert (lokal zwischengespeichert)", "err");
      }
      renderSchedule();
      updateTables();
      renderKO();
      updateKPIs();
    });
  });
}

function computeStandings(){
  const standings = { "A": {}, "B": {} };
  for(const g of Object.keys(GROUPS)){
    for(const t of GROUPS[g]) standings[g][t] = {Team:t, GP:0, W:0, L:0, SetsPlus:0, SetsMinus:0, GamesPlus:0, GamesMinus:0, Pts:0};
  }
  const h2h = { "A": {}, "B": {} };
  for(const grp of Object.keys(h2h)){ for(const t of GROUPS[grp]) h2h[grp][t] = {}; }

  SCHEDULE.forEach(([id, round, court, t1, t2, grp]) => {
    const r = state.matches["g"+id];
    const s1 = Number(r.sets1), s2 = Number(r.sets2);
    const g1 = Number(r.games1), g2 = Number(r.games2);
    const haveSets = isNumber(r.sets1) && isNumber(r.sets2);
    const haveGames = isNumber(r.games1) && isNumber(r.games2);
    if(!haveSets) return;
    standings[grp][t1].GP += 1;
    standings[grp][t2].GP += 1;
    standings[grp][t1].SetsPlus += s1; standings[grp][t1].SetsMinus += s2;
    standings[grp][t2].SetsPlus += s2; standings[grp][t2].SetsMinus += s1;
    if(haveGames){
      standings[grp][t1].GamesPlus += g1; standings[grp][t1].GamesMinus += g2;
      standings[grp][t2].GamesPlus += g2; standings[grp][t2].GamesMinus += g1;
    }
    if(s1 > s2){ standings[grp][t1].W++; standings[grp][t2].L++; standings[grp][t1].Pts++; }
    else if(s2 > s1){ standings[grp][t2].W++; standings[grp][t1].L++; standings[grp][t2].Pts++; }
    const winner = s1===s2 ? null : (s1>s2 ? t1 : t2);
    const loser  = s1===s2 ? null : (s1>s2 ? t2 : t1);
    if(winner && loser){ h2h[grp][winner][loser] = (h2h[grp][winner][loser] || 0) + 1; }
  });

  function sortGroup(grp){
    const arr = Object.values(standings[grp]);
    arr.sort((a,b)=>{
      const p = b.Pts - a.Pts; if(p) return p;
      const sd = (b.SetsPlus-b.SetsMinus) - (a.SetsPlus-a.SetsMinus); if(sd) return sd;
      const gd = (b.GamesPlus-b.GamesMinus) - (a.GamesPlus-a.GamesMinus); if(gd) return gd;
      const h = ((a.Team in h2h[grp] && b.Team in h2h[grp][a.Team]) ? h2h[grp][a.Team][b.Team] : 0)
              - ((b.Team in h2h[grp] && a.Team in h2h[grp][b.Team]) ? h2h[grp][b.Team][a.Team] : 0);
      if(h) return -h;
      return a.Team.localeCompare(b.Team);
    });
    arr.forEach((r,i)=> r.Rang = i+1);
    return arr;
  }
  return {A: sortGroup("A"), B: sortGroup("B")};
}

function tableHTML(rows){
  return `
  <table>
    <thead>
      <tr>
        <th>#</th><th>Team</th><th>Spiele</th><th>Siege</th><th>Niederl.</th>
        <th>S√§tze +/‚àí</th><th>Spiele +/‚àí</th><th>Punkte</th>
      </tr>
    </thead>
    <tbody>
      ${rows.map(r=>`
        <tr>
          <td>${r.Rang}</td>
          <td>${r.Team}</td>
          <td>${r.GP}</td>
          <td>${r.W}</td>
          <td>${r.L}</td>
          <td>${r.SetsPlus}:${r.SetsMinus} (${r.SetsPlus - r.SetsMinus})</td>
          <td>${r.GamesPlus}:${r.GamesMinus} (${r.GamesPlus - r.GamesMinus})</td>
          <td>${r.Pts}</td>
        </tr>
      `).join("")}
    </tbody>
  </table>`;
}

function updateTables(){
  const {A, B} = computeStandings();
  document.getElementById("tableA").innerHTML = tableHTML(A);
  document.getElementById("tableB").innerHTML = tableHTML(B);
}

function allGroupFinished(grp){
  const needed = SCHEDULE.filter(s => s[5]===grp).length;
  let have = 0;
  for(const [id, round, court, t1, t2, g] of SCHEDULE){
    if(g!==grp) continue;
    const r = state.matches["g"+id];
    if(isNumber(r.sets1) && isNumber(r.sets2)) have++;
  }
  return have === needed;
}

function renderKO(){
  const br = document.getElementById("koBracket");
  br.innerHTML = "";
  const finishedA = allGroupFinished("A");
  const finishedB = allGroupFinished("B");
  const ready = finishedA && finishedB;
  const {A, B} = computeStandings();
  const A1 = A[0]?.Team, A2 = A[1]?.Team;
  const B1 = B[0]?.Team, B2 = B[1]?.Team;

  const K = state.KO;
  if(ready){
    K.SF1.t1 = A1; K.SF1.t2 = B2;
    K.SF2.t1 = B1; K.SF2.t2 = A2;
    const winner = (m)=> (m.s1===""||m.s2==="") ? null : (Number(m.s1)>Number(m.s2)? m.t1 : m.t2);
    const loser  = (m)=> (m.s1===""||m.s2==="") ? null : (Number(m.s1)>Number(m.s2)? m.t2 : m.t1);
    const w1 = winner(K.SF1), w2 = winner(K.SF2);
    const l1 = loser(K.SF1), l2 = loser(K.SF2);
    if(w1 && w2){ K.F.t1 = w1; K.F.t2 = w2; }
    if(l1 && l2){ K.P3.t1 = l1; K.P3.t2 = l2; }
  }

  function matchCard(key, title){
    const m = K[key];
    const el = document.createElement("div");
    el.className = "match-card";
    el.innerHTML = `
      <div class="title">${title}</div>
      <div class="team-row">
        <span class="name">${m.t1 || "‚Äî"}</span>
        <div class="row"><label class="muted">S√§tze</label>
          <input type="number" min="0" step="1" id="${key}_s1" value="${m.s1}">
        </div>
      </div>
      <div class="team-row">
        <span class="name">${m.t2 || "‚Äî"}</span>
        <div class="row"><label class="muted">S√§tze</label>
          <input type="number" min="0" step="1" id="${key}_s2" value="${m.s2}">
        </div>
      </div>
      <div class="hint">${ready? "Automatisch aus Gruppentabellen bef√ºllt." : "Wartet auf Abschluss der Gruppenphase."}</div>
    `;
    setTimeout(()=>{
      const s1 = document.getElementById(`${key}_s1`);
      const s2 = document.getElementById(`${key}_s2`);
      if(s1) s1.addEventListener("input", async (e)=>{
        state.KO[key].s1 = e.target.value;
        if(USE_LOCAL_CACHE) saveLocal(state);
        try{ await serverPatch(["KO", key], state.KO[key]); setSyncStatus("‚úÖ Synchronisiert", "ok"); }
        catch{ setSyncStatus("‚ö†Ô∏è Nicht synchronisiert (lokal zwischengespeichert)", "err"); }
        renderKO();
      });
      if(s2) s2.addEventListener("input", async (e)=>{
        state.KO[key].s2 = e.target.value;
        if(USE_LOCAL_CACHE) saveLocal(state);
        try{ await serverPatch(["KO", key], state.KO[key]); setSyncStatus("‚úÖ Synchronisiert", "ok"); }
        catch{ setSyncStatus("‚ö†Ô∏è Nicht synchronisiert (lokal zwischengespeichert)", "err"); }
        renderKO();
      });
    }, 0);
    return el;
  }

  const col1 = document.createElement("div");
  const col2 = document.createElement("div");
  const col3 = document.createElement("div");
  col1.appendChild(matchCard("SF1","Halbfinale 1 (A1 vs B2)"));
  col1.appendChild(matchCard("P3","Spiel um Platz 3"));
  col3.appendChild(matchCard("SF2","Halbfinale 2 (B1 vs A2)"));
  col2.appendChild(matchCard("F","Finale"));
  br.appendChild(col1); br.appendChild(col2); br.appendChild(col3);
}

function updateKPIs(){
  const played = Object.keys(state.matches).filter(k=>{
    const r = state.matches[k]; return isNumber(r.sets1)&&isNumber(r.sets2);
  }).length;
  const total = SCHEDULE.length;
  const doneA = allGroupFinished("A");
  const doneB = allGroupFinished("B");
  const kpis = document.getElementById("kpis");
  kpis.innerHTML = `
    <div class="tile"><div class="label">Turnier</div><div class="value">${TOURNAMENT_NAME}</div></div>
    <div class="tile"><div class="label">Gespielte Spiele</div><div class="value">${played}/${total}</div></div>
    <div class="tile"><div class="label">Gruppe A ‚Äì Status</div><div class="value">${doneA? "abgeschlossen" : "l√§uft"}</div></div>
    <div class="tile"><div class="label">Gruppe B ‚Äì Status</div><div class="value">${doneB? "abgeschlossen" : "l√§uft"}</div></div>
  `;
}

// Tabs
document.querySelectorAll(".tab").forEach(t=>{
  t.addEventListener("click", ()=>{
    document.querySelectorAll(".tab").forEach(x=>x.classList.remove("active"));
    t.classList.add("active");
    document.querySelectorAll("main section").forEach(s=> s.style.display="none");
    document.getElementById(t.dataset.tab).style.display = "";
  });
});

// Export & Reset (nur lokal)
document.getElementById("downloadJson").addEventListener("click", ()=>{
  const blob = new Blob([JSON.stringify(state, null, 2)], {type:"application/json"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url; a.download = "tco_doppelmaster_2025_results.json"; a.click();
  setTimeout(()=>URL.revokeObjectURL(url), 2000);
});
document.getElementById("resetAll").addEventListener("click", ()=>{
  if(confirm("Nur den lokalen Cache l√∂schen? (Serverdaten bleiben erhalten)")){
    resetLocal(); location.reload();
  }
});

// Initial boot: server ‚Üí local fallback
(async function boot(){
  const fromServer = await serverLoad();
  if(fromServer){
    state = fromServer;
  } else if(USE_LOCAL_CACHE){
    state = loadLocal();
  } else {
    state = {};
  }
  ensureState();
  if(USE_LOCAL_CACHE) saveLocal(state);
  renderSchedule();
  updateTables();
  renderKO();
  updateKPIs();
})();
</script>
</body>
</html>
